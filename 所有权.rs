/*
Rust 中的每个值都有一个变量，称为其所有者
一次只能有一个所有者
当所有者不在程序运行范围内时，该值将被删除
*/

{
    // 在声明之前，变量s无效
    let s = "runoob";
    // 这里是s的作用范围
}

// 变量范围已经结束，变量s无效，并且s占有的资源被释放
fn main()
{
    let x=5;
    let y=x;
    //基本数据类型会直接复制
    let s1 = String::from("hello");
    let s2 = s1;
    //这样s2类似于指针，hello不会被复制，只有一份
    /*如果s1，s2都指向hello，那么由于释放规则，在s1，s2作用域结束时，hello会被释放两次，这显然是不被允许的，为了确保安全，在给s2赋值时s1就已经无效了。
    下面是错的
    */
    println!("{}, world!", s1);  //s1已经失效
    //想要复制，就需要用到克隆

    let s1 = s2.clone();
    println!("s1 = {}, s2 = {}", s1, s2);


}

